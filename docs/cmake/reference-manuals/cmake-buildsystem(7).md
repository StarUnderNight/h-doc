# cmake构建系统

## 介绍
该构建系统基于CMake,他由若干高级逻辑目标组成。 每个目标对应一个可执行文件、库，或者是一个包含自定义命令的自定义目标。
构建系统中定义了目标之间的依赖关系，这些依赖关系会决定构建顺序以及内容变更时的重新生成规则

## 二进制目标
`add_executable()`和`add_library()`命令分别用于定义**可执行文件**和**库**。生成的二进制文件根据目标平台会自动带上合适的前缀、后缀以及扩展名。
`target_link_libraries()`命令用于表示二进制目标之间的依赖关系。
```cmake
add_library(archive archive.cpp zip.cpp lzma.cpp)
add_executable(zipapp zipapp.cpp)
target_link_libraries(zipapp archive)
```
**更像是规则的集合**
上面的构建系统中：
- 第一行，定义了一个静态库`archive`，这个静态库中有由`archive.cpp`,`zip.cpp`以及`lzma.cpp`等源文件编译得到的对象.
- 第二行，定义了一个可执行目标，该目标(.o/.obj)依赖于`zipapp.cpp`。编译时不涉及到外部库。
- 第三行，告诉链接器，链接`zipapp`时需要加入`archive`这个静态库。从而链接器才会在链接阶段将`archive`和目标文件链接，最后生成可执行文件

### 可执行文件
可执行文件是由链接对象一起创建的二进制文件，其中一个链接对象应该包含一个程序入口点（main函数)
`add_executable()`命令用于定义**可执行目标**
```cmake
add_executable(mytool mytool.cpp)
``` 
CMake生成构建规则并用于将源文件编译为目标文件，同时将目标文件链接为可执行文件。可执行文件的链接依赖可以通过`target_link_libraries()`命令来
指定。链接器从可执行文件自己源文件编译而成的目标文件开始，然后通过查找链接库来解析剩余符号依赖。
诸如`add_custom_command()`这类用于生成**构建时待执行规则**的命令，可直接将一个EXECUTABLE目标用作COMMAND对应的可执行文件。
构建系统的规则会确保：在尝试运行该命令之前，先完成该可执行文件的构建。

### 静态库
> 技术过程：
> 1、编译阶段：您的源代码（如 .c 文件）被编译器（Compiler）主动编译成目标文件（.o 文件）。
> 2、打包阶段：多个目标文件被归档工具（Archiver，如 ar）主动打包成一个静态库（.a 文件）。此时，静态库是被动的产物。
> 3、链接阶段：
> * 您告诉链接器（Linker）："我想生成一个可执行文件，它需要用到某个静态库里的功能。"
> * 链接器主动地打开这个被动的静态库（就像打开一个文件柜）。
> * 链接器在库中主动地寻找、筛选（select subsets）那些包含了所需符号（函数、变量等）的目标文件。
> * 链接器将这些挑出来的目标文件主动地复制、合并到最终的可执行文件中。

静态库其实是目标文件的归档，他们由归档器来创建，而不是链接器。可执行文件、共享库以及模块库在链接时能将静态库作为依赖项进行链接。链接器根据符号
解析需求从静态库中选择目标文件的子集，然后将其链接为待生成的二进制文件。每个链接了静态库的二进制文件都会有静态库中所需文件的拷贝，
静态库则在运行时不再需要。

使用`add_library()`命令并指定`STATIC`库类型来定义静态库
```cmake 
add_library(archive STATIC archive.cpp zip.cpp lzma.cpp)
```
或者`BUILD_SHARED_LIBS`变量为false，可以不用携带类型
```cmake
add_library(archive archive.cpp zip.cpp lzma.cpp)
```
CMake生成构建规则并将该规则用于将源文件编译为目标文件，然后将这些目标文件归档为静态库

可以通过`target_link_libraries()`命令来指定要使用的静态库。

### 共享库

### 苹果框架

### 模块库

### 对象库

## 构建规范和使用要求

### 目标命令

### 目标构建规范


#### 目标编译属性

#### 目标链接属性